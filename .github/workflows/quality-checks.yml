name: Quality Checks & Testing Pipeline

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]
  push:
    branches: [main]
  workflow_dispatch:

# Ensure only one instance of this workflow runs per PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write

env:
  NODE_VERSION: "20"
  CI: true

jobs:
  # Quality Gates - Fast fail if basic quality checks don't pass
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Generate cache key
        id: cache-key
        run: echo "key=deps-${{ hashFiles('package-lock.json') }}" >> $GITHUB_OUTPUT

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: TypeScript Compilation Check
        run: |
          echo "::group::TypeScript Compilation"
          npm run type-check
          echo "::endgroup::"

      - name: ESLint Quality Check
        run: |
          echo "::group::ESLint Quality Check"
          npm run lint
          echo "::endgroup::"

      - name: Build Verification
        run: |
          echo "::group::Production Build"
          npm run build
          echo "::endgroup::"

      - name: Cache build artifacts
        uses: actions/cache@v4
        with:
          path: |
            dist/
            node_modules/
          key: ${{ steps.cache-key.outputs.key }}-build-${{ github.sha }}

  # Unit Tests with Coverage
  unit-tests:
    name: Unit Tests & Coverage
    runs-on: ubuntu-latest
    needs: quality-gates
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Restore cached dependencies
        uses: actions/cache@v4
        with:
          path: node_modules/
          key: ${{ needs.quality-gates.outputs.cache-key }}
          restore-keys: |
            deps-

      - name: Install dependencies (if cache miss)
        run: |
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit
          fi

      - name: Run Unit Tests with Coverage
        run: |
          echo "::group::Unit Test Execution"
          npm run test:coverage -- --run --reporter=verbose
          echo "::endgroup::"

      - name: Generate Coverage Report
        run: |
          echo "::group::Coverage Analysis"
          if [ -d "coverage" ]; then
            echo "Coverage report generated successfully"
            find coverage -name "*.html" -o -name "*.json" | head -5
          else
            echo "Warning: No coverage directory found"
          fi
          echo "::endgroup::"

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports-${{ github.run_id }}
          path: |
            coverage/
            test-results.xml
          retention-days: 30

      - name: Comment Coverage Results on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let coverageComment = '## üìä Test Coverage Report\n\n';
            
            try {
              if (fs.existsSync('coverage/coverage-summary.json')) {
                const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
                const total = coverage.total;
                
                coverageComment += `| Metric | Coverage | Threshold | Status |\n`;
                coverageComment += `|--------|----------|-----------|--------|\n`;
                coverageComment += `| Lines | ${total.lines.pct}% | 70% | ${total.lines.pct >= 70 ? '‚úÖ' : '‚ùå'} |\n`;
                coverageComment += `| Functions | ${total.functions.pct}% | 70% | ${total.functions.pct >= 70 ? '‚úÖ' : '‚ùå'} |\n`;
                coverageComment += `| Branches | ${total.branches.pct}% | 70% | ${total.branches.pct >= 70 ? '‚úÖ' : '‚ùå'} |\n`;
                coverageComment += `| Statements | ${total.statements.pct}% | 70% | ${total.statements.pct >= 70 ? '‚úÖ' : '‚ùå'} |\n\n`;
                
                if (total.lines.pct >= 70 && total.functions.pct >= 70 && total.branches.pct >= 70 && total.statements.pct >= 70) {
                  coverageComment += '‚úÖ **All coverage thresholds met!**\n';
                } else {
                  coverageComment += '‚ùå **Coverage thresholds not met. Please add more tests.**\n';
                }
              } else {
                coverageComment += '‚ö†Ô∏è Coverage report not found. Tests may not have run properly.\n';
              }
            } catch (error) {
              coverageComment += `‚ùå Error reading coverage report: ${error.message}\n`;
            }
            
            coverageComment += `\nü§ñ Generated by Quality Checks Pipeline`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes('üìä Test Coverage Report')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: coverageComment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: coverageComment
              });
            }

  # Quality Enforcement - Enforce coverage thresholds
  quality-enforcement:
    name: Quality Enforcement
    runs-on: ubuntu-latest
    needs: [quality-gates, unit-tests]
    timeout-minutes: 5
    if: always()
    steps:
      - name: Check Quality Gates Status
        if: needs.quality-gates.result != 'success'
        run: |
          echo "‚ùå Quality gates failed. Please fix the following issues:"
          echo "- TypeScript compilation errors"
          echo "- ESLint rule violations"  
          echo "- Build failures"
          exit 1

      - name: Download Coverage Reports
        uses: actions/download-artifact@v4
        if: needs.unit-tests.result == 'success'
        with:
          name: coverage-reports-${{ github.run_id }}
          path: coverage/

      - name: Enforce Coverage Thresholds
        if: needs.unit-tests.result == 'success'
        run: |
          echo "::group::Coverage Threshold Enforcement"
          
          if [ -f "coverage/coverage-summary.json" ]; then
            # Use node to parse JSON and check thresholds
            node -e "
              const fs = require('fs');
              const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
              const total = coverage.total;
              
              console.log('üìä Coverage Results:');
              console.log(\`Lines: \${total.lines.pct}%\`);
              console.log(\`Functions: \${total.functions.pct}%\`);
              console.log(\`Branches: \${total.branches.pct}%\`);
              console.log(\`Statements: \${total.statements.pct}%\`);
              
              const threshold = 70;
              const failures = [];
              
              if (total.lines.pct < threshold) failures.push(\`Lines: \${total.lines.pct}% < \${threshold}%\`);
              if (total.functions.pct < threshold) failures.push(\`Functions: \${total.functions.pct}% < \${threshold}%\`);
              if (total.branches.pct < threshold) failures.push(\`Branches: \${total.branches.pct}% < \${threshold}%\`);
              if (total.statements.pct < threshold) failures.push(\`Statements: \${total.statements.pct}% < \${threshold}%\`);
              
              if (failures.length > 0) {
                console.log('‚ùå Coverage threshold failures:');
                failures.forEach(f => console.log(\`  - \${f}\`));
                process.exit(1);
              } else {
                console.log('‚úÖ All coverage thresholds met!');
              }
            "
          else
            echo "‚ö†Ô∏è Coverage report not found - tests may not have executed properly"
            exit 1
          fi
          
          echo "::endgroup::"

      - name: Unit Tests Status Check
        if: needs.unit-tests.result != 'success'
        run: |
          echo "‚ùå Unit tests failed. Please fix failing tests before merging."
          exit 1

  # Performance Testing
  performance-check:
    name: Performance Check
    runs-on: ubuntu-latest
    needs: quality-gates
    timeout-minutes: 10
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Restore cached build
        uses: actions/cache@v4
        with:
          path: |
            dist/
            node_modules/
          key: ${{ needs.quality-gates.outputs.cache-key }}-build-${{ github.sha }}

      - name: Install dependencies (if cache miss)
        run: |
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit
          fi

      - name: Build if not cached
        run: |
          if [ ! -d "dist" ]; then
            npm run build
          fi

      - name: Analyze Bundle Size
        run: |
          echo "::group::Bundle Analysis"
          
          # Basic bundle size check
          if [ -d "dist/assets" ]; then
            echo "üì¶ Bundle Size Analysis:"
            find dist/assets -name "*.js" -exec ls -lh {} \; | awk '{print $5 "\t" $9}' | sort -hr
            
            # Check for excessively large bundles
            large_files=$(find dist/assets -name "*.js" -size +500k)
            if [ -n "$large_files" ]; then
              echo "‚ö†Ô∏è Large bundle files detected (>500KB):"
              echo "$large_files"
              echo "Consider code splitting or removing unused dependencies"
            else
              echo "‚úÖ Bundle sizes look good"
            fi
          else
            echo "‚ùå No dist/assets directory found"
            exit 1
          fi
          
          echo "::endgroup::"

  # Security Scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: quality-gates
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run Security Audit
        run: |
          echo "::group::NPM Security Audit"
          
          # Run audit and capture output
          if npm audit --audit-level=moderate --json > audit-results.json; then
            echo "‚úÖ No moderate or high severity vulnerabilities found"
          else
            echo "‚ö†Ô∏è Security vulnerabilities detected:"
            npm audit --audit-level=moderate
            echo ""
            echo "Please run 'npm audit fix' to address these issues"
            
            # Don't fail on moderate vulnerabilities in development dependencies
            # but warn about them
            echo "::warning::Security vulnerabilities found. Please review and fix."
          fi
          
          echo "::endgroup::"

      - name: Upload Security Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-audit-${{ github.run_id }}
          path: audit-results.json
          retention-days: 30

  # Final Status Check
  status-check:
    name: Overall Status
    runs-on: ubuntu-latest
    needs: [quality-gates, unit-tests, quality-enforcement, performance-check, security-scan]
    if: always()
    timeout-minutes: 2
    steps:
      - name: Check Overall Status
        run: |
          echo "::group::Pipeline Status Summary"
          
          echo "üîç Quality Gates: ${{ needs.quality-gates.result }}"
          echo "üß™ Unit Tests: ${{ needs.unit-tests.result }}"
          echo "üìè Quality Enforcement: ${{ needs.quality-enforcement.result }}"
          echo "‚ö° Performance Check: ${{ needs.performance-check.result || 'skipped' }}"
          echo "üîí Security Scan: ${{ needs.security-scan.result }}"
          
          # Check if any required jobs failed
          if [[ "${{ needs.quality-gates.result }}" != "success" ]] || \
             [[ "${{ needs.unit-tests.result }}" != "success" ]] || \
             [[ "${{ needs.quality-enforcement.result }}" != "success" ]]; then
            echo ""
            echo "‚ùå Pipeline failed. Please address the issues above."
            exit 1
          else
            echo ""
            echo "‚úÖ All quality checks passed! Ready for merge."
          fi
          
          echo "::endgroup::"

      - name: Set Status Check
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const state = '${{ needs.quality-gates.result }}' === 'success' && 
                         '${{ needs.unit-tests.result }}' === 'success' && 
                         '${{ needs.quality-enforcement.result }}' === 'success' 
                         ? 'success' : 'failure';
            
            const description = state === 'success' 
              ? 'All quality checks passed'
              : 'Quality checks failed';
              
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: state,
              target_url: `${context.payload.repository.html_url}/actions/runs/${context.runId}`,
              description: description,
              context: 'ci/quality-pipeline'
            });